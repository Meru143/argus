# RepoMap Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement `argus map` — tree-sitter symbol extraction, PageRank ranking, token budgeting, ASCII tree output, integrated into review pipeline.

**Architecture:** Five modules in argus-repomap (walker → parser → graph → budget → output), wired through lib.rs. Integration into argus-review prompt/pipeline. CLI subcommand with --path, --max-tokens, --focus.

**Tech Stack:** tree-sitter + language grammars, petgraph (PageRank), ignore (file walking), serde/serde_json

---

### Task 1: Add workspace dependencies and configure Cargo.toml files

**Files:**
- Modify: `/home/meru/argus/Cargo.toml` (workspace deps)
- Modify: `/home/meru/argus/crates/argus-repomap/Cargo.toml`

**Step 1: Add workspace dependencies**

Add to `[workspace.dependencies]` in root Cargo.toml:
```toml
tree-sitter = "0.24"
tree-sitter-rust = "0.24"
tree-sitter-python = "0.23"
tree-sitter-typescript = "0.23"
tree-sitter-javascript = "0.23"
tree-sitter-go = "0.23"
petgraph = "0.7"
ignore = "0.4"
```

Note: Check crates.io for compatible versions. tree-sitter 0.24 may need matching grammar versions.

**Step 2: Update argus-repomap/Cargo.toml**

```toml
[dependencies]
argus-core = { workspace = true }
tree-sitter = { workspace = true }
tree-sitter-rust = { workspace = true }
tree-sitter-python = { workspace = true }
tree-sitter-typescript = { workspace = true }
tree-sitter-javascript = { workspace = true }
tree-sitter-go = { workspace = true }
petgraph = { workspace = true }
ignore = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
```

**Step 3: Verify it compiles**

Run: `cargo check -p argus-repomap`
Expected: Compiles (possibly with unused warnings)

---

### Task 2: Implement walker.rs — gitignore-aware file discovery

**Files:**
- Create: `crates/argus-repomap/src/walker.rs`
- Modify: `crates/argus-repomap/src/lib.rs`

**Types:** `SourceFile { path, language, content }`, `Language { Rust, Python, TypeScript, JavaScript, Go, Unknown }`

**Key behaviors:**
- `ignore::WalkBuilder` for .gitignore-aware walking
- Skip binary files (check first 8KB for null bytes)
- Skip files > 1MB
- Map extensions → Language enum
- Skip Language::Unknown files
- Return paths relative to repo root
- `Language::tree_sitter_language()` returns correct grammar for each

**Tests (4):**
- Walk temp dir with mixed files
- .gitignore respected
- Binary files skipped
- Large files skipped (+ unknown extensions skipped)

**Commit:** `feat(repomap): add gitignore-aware file walker`

---

### Task 3: Implement parser.rs — tree-sitter symbol extraction

**Files:**
- Create: `crates/argus-repomap/src/parser.rs`
- Modify: `crates/argus-repomap/src/lib.rs`

**Types:** `Symbol { name, kind, file, line, signature, token_cost }`, `SymbolKind { Function, Method, Struct, Enum, Trait, Impl, Class, Interface, Module }`, `Reference { from_file, from_symbol, to_name, line }`

**Functions:** `extract_symbols(file) -> Vec<Symbol>`, `extract_references(file) -> Vec<Reference>`

**Tree-sitter queries per language:** As specified in spec (Rust fn/struct/enum/trait/impl, Python def/class, TS/JS function/class/method/arrow, Go func/method/struct/interface).

**Signature extraction:** Text from node start to opening `{`, trimmed, collapsed to single line.

**Token cost:** `signature.len() / 4`

**Tests (5+):**
- Rust file → correct fn, struct, enum, trait, impl symbols
- Python file → correct def, class symbols
- TypeScript file → correct function, class, arrow fn symbols
- Empty file → empty vec
- Syntax errors → partial results
- References extracted correctly

**Commit:** `feat(repomap): add tree-sitter symbol extraction for 5 languages`

---

### Task 4: Implement graph.rs — symbol graph + PageRank

**Files:**
- Create: `crates/argus-repomap/src/graph.rs`

**Types:** `SymbolGraph { graph, name_to_index }`, `SymbolNode { symbol, rank }`

**Methods:** `build(symbols, references)`, `compute_pagerank()` (d=0.85, 20 iterations), `ranked_symbols()`, `ranked_symbols_for_files(focus_files)` (2x multiplier)

**PageRank:** `PR(A) = (1-d)/N + d * Σ(PR(T)/C(T))` — ~15 lines of manual implementation using petgraph.

**Tests (4):**
- A→B→C: PageRank(C) > PageRank(A)
- Disconnected nodes get base rank
- Focus files boost works
- Empty graph → empty results

**Commit:** `feat(repomap): add symbol graph with PageRank ranking`

---

### Task 5: Implement budget.rs — token budgeting

**Files:**
- Create: `crates/argus-repomap/src/budget.rs`

**Function:** `fit_to_budget(symbols, max_tokens) -> Vec<&SymbolNode>` — greedy scan from highest rank, accumulate token_cost, stop when exceeded.

**Tests (4):**
- Budget 100, 5 symbols of 30 → selects 3
- Budget 0 → empty
- Budget larger than all → returns all
- Single symbol exactly at budget → included

**Commit:** `feat(repomap): add token budgeting`

---

### Task 6: Implement output.rs — ASCII tree, JSON, Markdown

**Files:**
- Create: `crates/argus-repomap/src/output.rs`

**Functions:** `format_tree(symbols)`, `format_json(symbols)`, `format_markdown(symbols)`

**ASCII tree:** Group by file (alphabetical), order within file by line number, box-drawing chars (├── └── │), show `{kind} {signature}` truncated to ~80 chars.

**Tests (3):**
- Tree with multiple files
- Single file
- Empty → empty string

**Commit:** `feat(repomap): add ASCII tree and JSON output formatting`

---

### Task 7: Wire lib.rs and add public generate_map API

**Files:**
- Modify: `crates/argus-repomap/src/lib.rs`

Expose all modules and add a convenience function:
```rust
pub fn generate_map(root: &Path, max_tokens: usize, focus_files: &[PathBuf], format: OutputFormat) -> Result<String>
```

This orchestrates: walk → parse → build graph → pagerank → budget → format.

---

### Task 8: Integrate repo map into argus-review

**Files:**
- Modify: `crates/argus-review/src/prompt.rs` — `build_review_prompt` gains `repo_map: Option<&str>` parameter
- Modify: `crates/argus-review/src/pipeline.rs` — pipeline generates map before LLM call when repo path configured

**prompt.rs change:** Add `repo_map` param. When Some, prepend:
```
Here is the codebase structure for context:

```
{repo_map}
```
```

**pipeline.rs change:** `ReviewPipeline::review()` accepts optional `repo_path: Option<&Path>`. If set, generate map with diff file paths as focus files. Pass map into prompt.

**Commit:** `feat(review): integrate repo map into review pipeline`

---

### Task 9: Wire CLI — map subcommand + review --repo

**Files:**
- Modify: `src/main.rs`

**Map subcommand:** Add `--path` (default "."), `--max-tokens` (default 1024), `--focus` (Vec<PathBuf>). Call `argus_repomap::generate_map()`, output in requested format.

**Review subcommand:** Add `--repo: Option<PathBuf>`. Pass to pipeline.

**Commit:** `feat(cli): wire map subcommand with --path, --max-tokens, --focus`

---

### Task 10: Integration test

**Files:**
- Create: `crates/argus-repomap/tests/integration.rs`

Walk → parse → rank → format end-to-end on the argus repo itself. Assert output contains known symbols.

**Commit:** `test(repomap): add integration test using argus repo`

---

### Task 11: Final verification

Run:
- `cargo run -- map --path . --max-tokens 500` → outputs ranked symbol tree
- `cargo run -- map --path . --focus src/main.rs` → boosts main.rs
- `cargo run -- map --format json --path .` → valid JSON
- `cargo test --workspace` → all pass
- `cargo clippy --workspace -- -D warnings` → clean
- `cargo fmt --check` → clean
